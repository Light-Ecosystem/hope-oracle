{
  "language": "Solidity",
  "sources": {
    "contracts/access/HopeOneRole.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {Errors} from '../libraries/Errors.sol';\nimport {Ownable2Step} from '../dependencies/openzeppelin/Ownable2Step.sol';\nimport {AccessControl} from '../dependencies/openzeppelin/AccessControl.sol';\n\nabstract contract HopeOneRole is Ownable2Step, AccessControl {\n  bytes32 public constant OPERATOR_ROLE = keccak256('OPERATOR_ROLE');\n\n  function isOperator(address _operator) external view returns (bool) {\n    return hasRole(OPERATOR_ROLE, _operator);\n  }\n\n  function addOperator(address _operator) external onlyOwner {\n    require(_operator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    _grantRole(OPERATOR_ROLE, _operator);\n  }\n\n  function removeOperator(address _operator) external onlyOwner {\n    require(_operator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    _revokeRole(OPERATOR_ROLE, _operator);\n  }\n}\n"
    },
    "contracts/dependencies/chainlink/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}"
    },
    "contracts/dependencies/chainlink/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}"
    },
    "contracts/dependencies/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    "contracts/dependencies/chainlink/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}"
    },
    "contracts/dependencies/openzeppelin/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport './IAccessControl.sol';\nimport './Context.sol';\nimport './Strings.sol';\nimport './ERC165.sol';\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _checkRole(role);\n    _;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public virtual override view returns (bool) {\n    return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) public virtual override view returns (bool) {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n   * Overriding this function changes the behavior of the {onlyRole} modifier.\n   *\n   * Format of the revert message is described in {_checkRole}.\n   *\n   * _Available since v4.6._\n   */\n  function _checkRole(bytes32 role) internal virtual view {\n    _checkRole(role, _msgSender());\n  }\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _checkRole(bytes32 role, address account) internal virtual view {\n    if (!hasRole(role, account)) {\n      revert(\n        string(\n          abi.encodePacked(\n            'AccessControl: account ',\n            Strings.toHexString(account),\n            ' is missing role ',\n            Strings.toHexString(uint256(role), 32)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) public virtual override view returns (bytes32) {\n    return _roles[role].adminRole;\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   *\n   * May emit a {RoleGranted} event.\n   */\n  function grantRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function revokeRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function renounceRole(bytes32 role, address account) public virtual override {\n    require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\n\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * May emit a {RoleGranted} event.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   *\n   * NOTE: This function is deprecated in favor of {_grantRole}.\n   */\n  function _setupRole(bytes32 role, address account) internal virtual {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * Internal function without access restriction.\n   *\n   * May emit a {RoleGranted} event.\n   */\n  function _grantRole(bytes32 role, address account) internal virtual {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, _msgSender());\n    }\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * Internal function without access restriction.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function _revokeRole(bytes32 role, address account) internal virtual {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, _msgSender());\n    }\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/dependencies/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport './IERC165.sol';\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nimport './Context.sol';\nimport './IERC20.sol';\nimport './SafeMath.sol';\nimport './Address.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name, string memory symbol) {\n    _name = name;\n    _symbol = symbol;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        'ERC20: decreased allowance below zero'\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/dependencies/openzeppelin/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/dependencies/openzeppelin/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/dependencies/openzeppelin/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/dependencies/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/dependencies/openzeppelin/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/dependencies/openzeppelin/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.17;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}"
    },
    "contracts/dependencies/openzeppelin/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary SafeMath {\n  /// @notice Returns x + y, reverts if sum overflows uint256\n  /// @param x The augend\n  /// @param y The addend\n  /// @return z The sum of x and y\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x + y) >= x);\n    }\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x - y) <= x);\n    }\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @param message The error msg\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y, string memory message) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x - y) <= x, message);\n    }\n  }\n\n  /// @notice Returns x * y, reverts if overflows\n  /// @param x The multiplicand\n  /// @param y The multiplier\n  /// @return z The product of x and y\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require(x == 0 || (z = x * y) / x == y);\n    }\n  }\n\n  /// @notice Returns x / y, reverts if overflows - no specific check, solidity reverts on division by 0\n  /// @param x The numerator\n  /// @param y The denominator\n  /// @return z The product of x and y\n  function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    return x / y;\n  }\n}\n"
    },
    "contracts/dependencies/openzeppelin/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/HopeFallbackOracle.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {AggregatorInterface} from './dependencies/chainlink/AggregatorInterface.sol';\nimport {Errors} from './libraries/Errors.sol';\nimport {HopeOneRole} from './access/HopeOneRole.sol';\nimport {IHopeFallbackOracle} from './interfaces/IHopeFallbackOracle.sol';\n\n/**\n * @title HopeFallbackOracle\n * @author Hope\n * @notice Contract to get asset prices, manage price sources\n * - Use of Chainlink Aggregators as first source of price\n * - Owned by the Hope governance\n */\ncontract HopeFallbackOracle is IHopeFallbackOracle, HopeOneRole {\n  // Map of asset price sources (asset => AggregatorInterface)\n  mapping(address => AggregatorInterface) private assetsSources;\n\n  address public immutable override BASE_CURRENCY;\n  uint256 public immutable override BASE_CURRENCY_UNIT;\n\n  /**\n   * @notice Constructor\n   * @param assets The addresses of the assets\n   * @param sources The address of the source of each asset\n   * @param baseCurrency The base currency used for the price quotes. If USD is used, base currency is 0x0\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  constructor(address[] memory assets, address[] memory sources, address baseCurrency, uint256 baseCurrencyUnit) {\n    _setAssetsSources(assets, sources);\n    BASE_CURRENCY = baseCurrency;\n    BASE_CURRENCY_UNIT = baseCurrencyUnit;\n    emit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n  }\n\n  /// @inheritdoc IHopeFallbackOracle\n  function setAssetSources(\n    address[] calldata assets,\n    address[] calldata sources\n  ) external override onlyRole(OPERATOR_ROLE) {\n    _setAssetsSources(assets, sources);\n  }\n\n  /**\n   * @notice Internal function to set the sources for each asset\n   * @param assets The addresses of the assets\n   * @param sources The address of the source of each asset\n   */\n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal {\n    require(assets.length == sources.length, Errors.INCONSISTENT_PARAMS_LENGTH);\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsSources[assets[i]] = AggregatorInterface(sources[i]);\n      emit AssetSourceUpdated(assets[i], sources[i]);\n    }\n  }\n\n  function getAssetPrice(address asset) public view override returns (uint256) {\n    AggregatorInterface source = assetsSources[asset];\n\n    if (asset == BASE_CURRENCY) {\n      return BASE_CURRENCY_UNIT;\n    } else {\n      int256 price = source.latestAnswer();\n      return uint256(price);\n    }\n  }\n\n  /// @inheritdoc IHopeFallbackOracle\n  function getAssetsPrices(address[] calldata assets) external view override returns (uint256[] memory) {\n    uint256[] memory prices = new uint256[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      prices[i] = getAssetPrice(assets[i]);\n    }\n    return prices;\n  }\n\n  /// @inheritdoc IHopeFallbackOracle\n  function getSourceOfAsset(address asset) external view override returns (address) {\n    return address(assetsSources[asset]);\n  }\n}\n"
    },
    "contracts/HopeOracle.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {AggregatorInterface} from './dependencies/chainlink/AggregatorInterface.sol';\nimport {Errors} from './libraries/Errors.sol';\nimport {IPriceOracleGetter} from './interfaces/IPriceOracleGetter.sol';\nimport {IHopeOracle} from './interfaces/IHopeOracle.sol';\nimport {HopeOneRole} from './access/HopeOneRole.sol';\n\n/**\n * @title HopeOracle\n * @author Hope\n * @notice Contract to get asset prices, manage price sources and update the fallback oracle\n * - Use of Chainlink Aggregators as first source of price\n * - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallback oracle\n * - Owned by the Hope governance\n */\ncontract HopeOracle is IHopeOracle, HopeOneRole {\n  struct PriceData {\n    AggregatorInterface source;\n    bool failoverActive;\n  }\n\n  // Map of asset price sources (asset => priceSource)\n  mapping(address => PriceData) private assetsPriceDatas;\n\n  IPriceOracleGetter private _fallbackOracle;\n  address public immutable override BASE_CURRENCY;\n  uint256 public immutable override BASE_CURRENCY_UNIT;\n\n  /**\n   * @notice Constructor\n   * @param assets The addresses of the assets\n   * @param sources The address of the source of each asset\n   * @param fallbackOracle The address of the fallback oracle to use if the data of an\n   *        aggregator is not consistent\n   * @param baseCurrency The base currency used for the price quotes. If USD is used, base currency is 0x0\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  constructor(\n    address[] memory assets,\n    address[] memory sources,\n    address fallbackOracle,\n    address baseCurrency,\n    uint256 baseCurrencyUnit\n  ) {\n    _setFallbackOracle(fallbackOracle);\n    _setAssetsSources(assets, sources);\n    BASE_CURRENCY = baseCurrency;\n    BASE_CURRENCY_UNIT = baseCurrencyUnit;\n    emit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n  }\n\n  /// @inheritdoc IHopeOracle\n  function setAssetSources(\n    address[] calldata assets,\n    address[] calldata sources\n  ) external override onlyRole(OPERATOR_ROLE) {\n    _setAssetsSources(assets, sources);\n  }\n\n  /// @inheritdoc IHopeOracle\n  function setFallbackOracle(address fallbackOracle) external override onlyRole(OPERATOR_ROLE) {\n    _setFallbackOracle(fallbackOracle);\n  }\n\n  /**\n   * @notice Activate the failover for an asset\n   * @param asset The address of the asset\n   */\n  function activateFailover(address asset) external override onlyRole(OPERATOR_ROLE) {\n    _activateFailover(asset);\n  }\n\n  /**\n   * @notice Deactivate the failover for an asset\n   * @param asset The address of the asset\n   */\n  function deactivateFailover(address asset) external override onlyRole(OPERATOR_ROLE) {\n    _deactivateFailover(asset);\n  }\n\n  /**\n   * @notice Internal function to set the sources for each asset\n   * @param assets The addresses of the assets\n   * @param sources The address of the source of each asset\n   */\n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal {\n    require(assets.length == sources.length, Errors.INCONSISTENT_PARAMS_LENGTH);\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsPriceDatas[assets[i]] = PriceData({source: AggregatorInterface(sources[i]), failoverActive: false});\n      emit AssetSourceUpdated(assets[i], sources[i]);\n    }\n  }\n\n  /**\n   * @notice Internal function to set the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function _setFallbackOracle(address fallbackOracle) internal {\n    _fallbackOracle = IPriceOracleGetter(fallbackOracle);\n    emit FallbackOracleUpdated(fallbackOracle);\n  }\n\n  /**\n   * @notice Internal function to activate the failover for an asset\n   * @param asset The address of the asset\n   */\n  function _activateFailover(address asset) internal {\n    PriceData storage priceData = assetsPriceDatas[asset];\n    require(!priceData.failoverActive, Errors.FAILOVER_ALREADY_ACTIVE);\n    priceData.failoverActive = true;\n    emit FailoverActivated(asset);\n  }\n\n  /**\n   * @notice Internal function to deactivate the failover for an asset\n   * @param asset The address of the asset\n   */\n  function _deactivateFailover(address asset) internal {\n    PriceData storage priceData = assetsPriceDatas[asset];\n    require(priceData.failoverActive, Errors.FAILOVER_ALREADY_DEACTIVATED);\n    priceData.failoverActive = false;\n    emit FailoverDeactivated(asset);\n  }\n\n  /// @inheritdoc IPriceOracleGetter\n  function getAssetPrice(address asset) public view override returns (uint256) {\n    PriceData storage priceData = assetsPriceDatas[asset];\n\n    if (asset == BASE_CURRENCY) {\n      return BASE_CURRENCY_UNIT;\n    } else if (address(priceData.source) == address(0)) {\n      return _fallbackOracle.getAssetPrice(asset);\n    } else if (priceData.failoverActive) {\n      return _fallbackOracle.getAssetPrice(asset);\n    } else {\n      int256 price = priceData.source.latestAnswer();\n      if (price > 0) {\n        return uint256(price);\n      } else {\n        return _fallbackOracle.getAssetPrice(asset);\n      }\n    }\n  }\n\n  /// @inheritdoc IHopeOracle\n  function getAssetsPrices(address[] calldata assets) external view override returns (uint256[] memory) {\n    uint256[] memory prices = new uint256[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      prices[i] = getAssetPrice(assets[i]);\n    }\n    return prices;\n  }\n\n  /// @inheritdoc IHopeOracle\n  function getSourceOfAsset(address asset) external view override returns (address) {\n    return address(assetsPriceDatas[asset].source);\n  }\n\n  /// @inheritdoc IHopeOracle\n  function getFailoverStatusOfAsset(address asset) external view override returns (bool) {\n    return assetsPriceDatas[asset].failoverActive;\n  }\n\n  /// @inheritdoc IHopeOracle\n  function getFallbackOracle() external view returns (address) {\n    return address(_fallbackOracle);\n  }\n}\n"
    },
    "contracts/HOPEPriceFeed/HopeAggregator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {IHopeAggregator} from '../interfaces/IHopeAggregator.sol';\nimport {HopeOneRole} from '../access/HopeOneRole.sol';\n\ncontract HopeAggregator is HopeOneRole, IHopeAggregator {\n  uint256 public constant override version = 1;\n  uint8 public immutable override decimals;\n  string public override description; // 'HOPE/USD'\n  address public transmitter;\n  uint80 internal roundId;\n\n  struct Transmission {\n    int192 answer; // 192 bits ought to be enough for anyone\n    uint64 timestamp;\n  }\n  mapping(uint80 /* aggregator round ID */ => Transmission) internal transmissions;\n\n  constructor(uint8 _decimals, string memory _description) {\n    decimals = _decimals;\n    description = _description;\n  }\n\n  function transmit(uint256 _answer) external override onlyRole(OPERATOR_ROLE) {\n    roundId++;\n    int192 currentPrice = int192(int256(_answer));\n    transmissions[roundId] = Transmission(currentPrice, uint64(block.timestamp));\n    emit AnswerUpdated(currentPrice, roundId, uint64(block.timestamp));\n  }\n\n  function latestAnswer() external view override returns (int256) {\n    return transmissions[roundId].answer;\n  }\n\n  function latestTimestamp() external view override returns (uint256) {\n    return transmissions[roundId].timestamp;\n  }\n\n  function latestRound() external view override returns (uint256) {\n    return roundId;\n  }\n\n  function getAnswer(uint256 _roundId) external view override returns (int256) {\n    return transmissions[uint80(_roundId)].answer;\n  }\n\n  function getTimestamp(uint256 _roundId) external view override returns (uint256) {\n    return transmissions[uint80(_roundId)].timestamp;\n  }\n\n  function getRoundData(uint80 _roundId) external view override returns (uint80, int256, uint256, uint256, uint80) {\n    Transmission memory transmission = transmissions[_roundId];\n    return (_roundId, transmission.answer, transmission.timestamp, transmission.timestamp, _roundId);\n  }\n\n  function latestRoundData() external view override returns (uint80, int256, uint256, uint256, uint80) {\n    Transmission memory transmission = transmissions[roundId];\n    return (roundId, transmission.answer, transmission.timestamp, transmission.timestamp, roundId);\n  }\n}\n"
    },
    "contracts/HOPEPriceFeed/HopeAutomation.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {HopeOneRole} from '../access/HopeOneRole.sol';\nimport {AutomationCompatibleInterface} from '../dependencies/chainlink/AutomationCompatibleInterface.sol';\nimport {IHOPEPriceFeed} from '../interfaces/IHOPEPriceFeed.sol';\nimport {IHopeAggregator} from '../interfaces/IHopeAggregator.sol';\n\ncontract HopeAutomation is HopeOneRole, AutomationCompatibleInterface {\n  uint256 internal constant THRESHOLD_FACTOR = 1e4;\n\n  address public priceFeed;\n  address public aggregator;\n\n  uint256 public heartbeat;\n  uint256 public deviationThreshold;\n\n  uint256 public lastPrice;\n  uint256 public lastTimestamp;\n\n  event HeartbeatUpdated(uint256 newHeartbeat);\n  event DeviationThresholdUpdated(uint256 newDeviationThreshold);\n  event HOPEPriceFeedUpdated(address newPriceFeed);\n  event AggregatorUpdated(address newAggregator);\n  event PriceUpdated(uint256 price, uint256 timestamp);\n\n  constructor(address _priceFeed, address _aggregator, uint256 _heartbeat, uint256 _deviationThreshold) {\n    _setHOPEPriceFeed(_priceFeed);\n    _setAggregator(_aggregator);\n    _setHeartbeat(_heartbeat);\n    _setDeviationThreshold(_deviationThreshold);\n  }\n\n  function setHeartbeat(uint256 _heartbeat) external onlyRole(OPERATOR_ROLE) {\n    _setHeartbeat(_heartbeat);\n  }\n\n  function setDeviationThreshold(uint256 _deviationThreshold) external onlyRole(OPERATOR_ROLE) {\n    _setDeviationThreshold(_deviationThreshold);\n  }\n\n  function setHOPEPriceFeed(address _priceFeed) external onlyRole(OPERATOR_ROLE) {\n    _setHOPEPriceFeed(_priceFeed);\n  }\n\n  function setAggregator(address _aggregator) external onlyRole(OPERATOR_ROLE) {\n    _setAggregator(_aggregator);\n  }\n\n  function _setHeartbeat(uint256 _heartbeat) internal {\n    heartbeat = _heartbeat;\n    emit HeartbeatUpdated(_heartbeat);\n  }\n\n  function _setDeviationThreshold(uint256 _deviationThreshold) internal {\n    deviationThreshold = _deviationThreshold;\n    emit DeviationThresholdUpdated(_deviationThreshold);\n  }\n\n  function _setHOPEPriceFeed(address _priceFeed) internal {\n    priceFeed = _priceFeed;\n    emit HOPEPriceFeedUpdated(_priceFeed);\n  }\n\n  function _setAggregator(address _aggregator) internal {\n    aggregator = _aggregator;\n    emit AggregatorUpdated(_aggregator);\n  }\n\n  function checkUpkeep(\n    bytes calldata /*checkData*/\n  ) external view override returns (bool upkeepNeeded, bytes memory /*performData*/) {\n    (, upkeepNeeded) = _checkUpKeep();\n  }\n\n  function performUpkeep(bytes memory /*performData*/) external override {\n    (uint256 price, bool upkeepNeeded) = _checkUpKeep();\n    require(upkeepNeeded, 'HopeAutomation: upkeep not needed');\n    lastPrice = price;\n    lastTimestamp = block.timestamp;\n    IHopeAggregator(aggregator).transmit(price);\n\n    emit PriceUpdated(price, block.timestamp);\n  }\n\n  function _checkUpKeep() internal view returns (uint256 price, bool upkeepNeeded) {\n    price = _getPrice();\n    upkeepNeeded = price > 0;\n    bool thresholdMet;\n    unchecked {\n      upkeepNeeded = upkeepNeeded && block.timestamp - lastTimestamp >= heartbeat;\n      if (price >= lastPrice) {\n        thresholdMet = price - lastPrice >= (deviationThreshold * lastPrice) / THRESHOLD_FACTOR;\n      } else {\n        thresholdMet = lastPrice - price >= (deviationThreshold * lastPrice) / THRESHOLD_FACTOR;\n      }\n      upkeepNeeded = upkeepNeeded || thresholdMet;\n    }\n  }\n\n  function _getPrice() internal view returns (uint256 price) {\n    price = IHOPEPriceFeed(priceFeed).latestAnswer();\n  }\n}\n"
    },
    "contracts/HOPEPriceFeed/HOPEPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {HopeOneRole} from '../access/HopeOneRole.sol';\nimport {AggregatorV2V3Interface} from '../dependencies/chainlink/AggregatorV2V3Interface.sol';\nimport {IHOPE} from '../interfaces/IHOPE.sol';\nimport {IHOPEPriceFeed} from '../interfaces/IHOPEPriceFeed.sol';\n\ncontract HOPEPriceFeed is HopeOneRole, IHOPEPriceFeed {\n  uint256 private constant K_FACTOR = 1e20;\n  uint256 private constant PRICE_SCALE = 1e8;\n  uint256 public immutable K; // 1080180484347501\n  address public immutable ETH_ADDRESS; // 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n  address public immutable BTC_ADDRESS; // 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\n  address public immutable HOPE_ADDRESS; // 0xc353Bf07405304AeaB75F4C2Fac7E88D6A68f98e\n\n  struct TokenConfig {\n    AggregatorV2V3Interface priceFeed;\n    uint256 factor;\n    bool isExist;\n  }\n  address[] private reserveTokens;\n  mapping(address => TokenConfig) private reserveTokenConfigs;\n\n  event ReserveUpdate(address[] tokens, address[] priceFeed, uint256[] factors);\n\n  constructor(address _ethMaskAddress, address _btcMaskAddress, address _hopeAddress, uint256 _k) {\n    ETH_ADDRESS = _ethMaskAddress;\n    BTC_ADDRESS = _btcMaskAddress;\n    HOPE_ADDRESS = _hopeAddress;\n    K = _k;\n  }\n\n  function setReserveTokens(\n    address[] memory tokens,\n    address[] memory priceFeeds,\n    uint256[] memory factors\n  ) external onlyRole(OPERATOR_ROLE) {\n    require(tokens.length == priceFeeds.length, 'HOPEPriceFeeds: Invalid input');\n    require(tokens.length == factors.length, 'HOPEPriceFeeds: Invalid input');\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (!reserveTokenConfigs[tokens[i]].isExist) {\n        reserveTokens.push(tokens[i]);\n      }\n      reserveTokenConfigs[tokens[i]] = TokenConfig(AggregatorV2V3Interface(priceFeeds[i]), factors[i], true);\n    }\n\n    emit ReserveUpdate(tokens, priceFeeds, factors);\n  }\n\n  function latestAnswer() external view override returns (uint256) {\n    uint256 hopeSupply = getHOPETotalSupply();\n    uint256 reserveTotalValue;\n    uint256 hopePrice;\n\n    unchecked {\n      for (uint256 i = 0; i < reserveTokens.length; i++) {\n        TokenConfig memory config = reserveTokenConfigs[reserveTokens[i]];\n        uint256 reserveInToken = _calculateReserveAmount(hopeSupply, config);\n        uint256 reserveValueInToken = _calculateReserveValue(reserveInToken, config);\n        reserveTotalValue += reserveValueInToken;\n      }\n\n      hopePrice = reserveTotalValue / hopeSupply;\n    }\n\n    if (hopePrice >= PRICE_SCALE) return PRICE_SCALE;\n    return hopePrice;\n  }\n\n  function _calculateReserveAmount(uint256 hopeSupply, TokenConfig memory config) internal view returns (uint256) {\n    unchecked {\n      uint256 reserveAmount = (hopeSupply * K * config.factor) / K_FACTOR;\n      return reserveAmount;\n    }\n  }\n\n  function _calculateReserveValue(uint256 reserveAmount, TokenConfig memory config) internal view returns (uint256) {\n    uint256 reservePrice = uint256(config.priceFeed.latestAnswer());\n    uint256 reserveDecimals = uint256(config.priceFeed.decimals());\n    unchecked {\n      uint256 reserveValue = (reserveAmount * reservePrice * PRICE_SCALE) / (10 ** reserveDecimals);\n      return reserveValue;\n    }\n  }\n\n  function getReservePrice(address token) external view returns (uint256) {\n    TokenConfig memory config = reserveTokenConfigs[token];\n    return uint256(config.priceFeed.latestAnswer());\n  }\n\n  function getHOPETotalSupply() public view returns (uint256) {\n    return IHOPE(HOPE_ADDRESS).totalSupply();\n  }\n\n  function getReserveTokens() external view returns (address[] memory) {\n    return reserveTokens;\n  }\n\n  function getReserveTokenConfig(address token) external view returns (address, uint256, bool) {\n    TokenConfig memory config = reserveTokenConfigs[token];\n    return (address(config.priceFeed), config.factor, config.isExist);\n  }\n}\n"
    },
    "contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IACLManager\n * @author HopeLend\n * @notice Defines the basic interface for the ACL Manager\n */\ninterface IACLManager {\n  /**\n   * @notice Returns the contract address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the identifier of the PoolAdmin role\n   * @return The id of the PoolAdmin role\n   */\n  function POOL_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the EmergencyAdmin role\n   * @return The id of the EmergencyAdmin role\n   */\n  function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the RiskAdmin role\n   * @return The id of the RiskAdmin role\n   */\n  function RISK_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the FlashBorrower role\n   * @return The id of the FlashBorrower role\n   */\n  function FLASH_BORROWER_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Bridge role\n   * @return The id of the Bridge role\n   */\n  function BRIDGE_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the AssetListingAdmin role\n   * @return The id of the AssetListingAdmin role\n   */\n  function ASSET_LISTING_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Set the role as admin of a specific role.\n   * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\n   * @param role The role to be managed by the admin role\n   * @param adminRole The admin role\n   */\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n  /**\n   * @notice Adds a new admin as PoolAdmin\n   * @param admin The address of the new admin\n   */\n  function addPoolAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as PoolAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removePoolAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is PoolAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is PoolAdmin, false otherwise\n   */\n  function isPoolAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as EmergencyAdmin\n   * @param admin The address of the new admin\n   */\n  function addEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as EmergencyAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is EmergencyAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is EmergencyAdmin, false otherwise\n   */\n  function isEmergencyAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as RiskAdmin\n   * @param admin The address of the new admin\n   */\n  function addRiskAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as RiskAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeRiskAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is RiskAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is RiskAdmin, false otherwise\n   */\n  function isRiskAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as FlashBorrower\n   * @param borrower The address of the new FlashBorrower\n   */\n  function addFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Removes an address as FlashBorrower\n   * @param borrower The address of the FlashBorrower to remove\n   */\n  function removeFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Returns true if the address is FlashBorrower, false otherwise\n   * @param borrower The address to check\n   * @return True if the given address is FlashBorrower, false otherwise\n   */\n  function isFlashBorrower(address borrower) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as Bridge\n   * @param bridge The address of the new Bridge\n   */\n  function addBridge(address bridge) external;\n\n  /**\n   * @notice Removes an address as Bridge\n   * @param bridge The address of the bridge to remove\n   */\n  function removeBridge(address bridge) external;\n\n  /**\n   * @notice Returns true if the address is Bridge, false otherwise\n   * @param bridge The address to check\n   * @return True if the given address is Bridge, false otherwise\n   */\n  function isBridge(address bridge) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as AssetListingAdmin\n   * @param admin The address of the new admin\n   */\n  function addAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as AssetListingAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is AssetListingAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is AssetListingAdmin, false otherwise\n   */\n  function isAssetListingAdmin(address admin) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/IERC20.sol';\n\n/**\n * @title IERC20WithPermit\n * @author Aave\n * @notice Interface for the permit function (EIP-2612)\n */\ninterface IERC20WithPermit is IERC20 {\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "contracts/interfaces/IHESynchronicityPriceAdapter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IHESynchronicityPriceAdapter {\n  /**\n   * @notice Calculates the current answer based on the aggregators.\n   * @return int256 latestAnswer\n   */\n  function latestAnswer() external view returns (int256);\n\n  /**\n   * @notice Returns the description of the feed\n   * @return string desciption\n   */\n  function description() external view returns (string memory);\n\n  /**\n   * @notice Returns the feed decimals\n   * @return uint8 decimals\n   */\n  function decimals() external view returns (uint8);\n\n  error DecimalsAboveLimit();\n  error DecimalsNotEqual();\n}\n"
    },
    "contracts/interfaces/IHOPE.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IHOPE {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IHopeAggregator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {AggregatorV2V3Interface} from '../dependencies/chainlink/AggregatorV2V3Interface.sol';\n\ninterface IHopeAggregator is AggregatorV2V3Interface {\n  function transmit(uint256 _answer) external;\n}\n"
    },
    "contracts/interfaces/IHopeFallbackOracle.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\n\n/**\n * @title IHopeFallbackOracle\n * @author Hope\n * @notice Defines the basic interface for the Hope Oracle\n */\ninterface IHopeFallbackOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IHopeOracle.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\n\n/**\n * @title IHopeOracle\n * @author Hope\n * @notice Defines the basic interface for the Hope Oracle\n */\ninterface IHopeOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @dev Emitted after the failover of an asset is activated\n   * @param asset The address of the asset\n   */\n  event FailoverActivated(address indexed asset);\n\n  /**\n   * @dev Emitted after the failover of an asset is deactivated\n   * @param asset The address of the asset\n   */\n  event FailoverDeactivated(address indexed asset);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Activates the failover for an asset\n   * @param asset The address of the asset\n   */\n  function activateFailover(address asset) external;\n\n  /**\n   * @notice Deactivates the failover for an asset\n   * @param asset The address of the asset\n   */\n  function deactivateFailover(address asset) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the failover status of an asset\n   * @param asset The address of the asset\n   * @return The failover status of the asset\n   */\n  function getFailoverStatusOfAsset(address asset) external view returns (bool);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IHOPEPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IHOPEPriceFeed {\n  function latestAnswer() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @title IPoolAddressesProvider\n * @author HopeLend\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(bytes32 indexed id, address indexed proxyAddress, address indexed implementationAddress);\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the HopeLend market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple HopeLend markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @title IPriceOracleGetter\n * @author HopeOracle\n * @notice Interface for the HopeOracle price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStETH.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IStETH {\n  function getPooledEthByShares(uint256 shares) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\n/**\n * @title Errors library\n * @author HopeLend\n * @notice Defines the error messages emitted by the different contracts of the HopeLend protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\n  string public constant FAILOVER_ALREADY_ACTIVE = '92'; // Failover is already active\n  string public constant FAILOVER_ALREADY_DEACTIVATED = '93'; // Failover is already deactivated\n}\n"
    },
    "contracts/mock/oracle/MockAggregator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport '../../dependencies/openzeppelin/AccessControl.sol';\nimport '../../dependencies/openzeppelin/Ownable2Step.sol';\n\ncontract MockAggregator is AccessControl, Ownable2Step {\n  bytes32 public constant OPERATOR_ROLE = keccak256('OPERATOR_ROLE');\n  int256 private _latestAnswer;\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  constructor(int256 initialAnswer) {\n    _latestAnswer = initialAnswer;\n    emit AnswerUpdated(initialAnswer, 0, block.timestamp);\n  }\n\n  function latestAnswer() external view returns (int256) {\n    return _latestAnswer;\n  }\n\n  function setLatestAnswer(int256 answer) external {\n    require(_msgSender() == owner() || hasRole(OPERATOR_ROLE, _msgSender()), 'Need operator role');\n    _latestAnswer = answer;\n    emit AnswerUpdated(answer, 0, block.timestamp);\n  }\n\n  function getTokenType() external pure returns (uint256) {\n    return 1;\n  }\n\n  function decimals() external pure returns (uint8) {\n    return 8;\n  }\n\n  function isOperator(address _operator) external view returns (bool) {\n    return hasRole(OPERATOR_ROLE, _operator);\n  }\n\n  function addOperator(address _operator) external onlyOwner {\n    _grantRole(OPERATOR_ROLE, _operator);\n  }\n\n  function removeOperator(address _operator) external onlyOwner {\n    _revokeRole(OPERATOR_ROLE, _operator);\n  }\n}\n"
    },
    "contracts/mock/token/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from '../../dependencies/openzeppelin/ERC20.sol';\nimport {IERC20WithPermit} from '../../interfaces/IERC20WithPermit.sol';\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract MintableERC20 is IERC20WithPermit, ERC20 {\n  bytes public constant EIP712_REVISION = bytes('1');\n  bytes32 internal constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  // Map of address nonces (address => nonce)\n  mapping(address => uint256) internal _nonces;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor(string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol) {\n    uint256 chainId = block.chainid;\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(EIP712_DOMAIN, keccak256(bytes(name)), keccak256(EIP712_REVISION), chainId, address(this))\n    );\n    _setupDecimals(decimals);\n  }\n\n  /// @inheritdoc IERC20WithPermit\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    require(owner != address(0), 'INVALID_OWNER');\n    //solium-disable-next-line\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\n    uint256 currentValidNonce = _nonces[owner];\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        DOMAIN_SEPARATOR,\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n      )\n    );\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\n    _nonces[owner] = currentValidNonce + 1;\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(uint256 value) public returns (bool) {\n    _mint(_msgSender(), value);\n    return true;\n  }\n\n  /**\n   * @dev Function to mint tokens to address\n   * @param account The account to mint tokens.\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(address account, uint256 value) public returns (bool) {\n    _mint(account, value);\n    return true;\n  }\n\n  function nonces(address owner) public view virtual returns (uint256) {\n    return _nonces[owner];\n  }\n}\n"
    },
    "contracts/WBTCSynchronicityPriceAdapter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {AggregatorV2V3Interface} from './dependencies/chainlink/AggregatorV2V3Interface.sol';\nimport {IHESynchronicityPriceAdapter} from './interfaces/IHESynchronicityPriceAdapter.sol';\n\n/**\n * @title HESynchronicityPriceAdapter\n * @author Hope Ecosystem\n * @notice Price adapter to calculate price of (Asset / Base) pair by using\n * @notice Chainlink Data Feeds for (Asset / Peg) and (Peg / Base) pairs.\n * @notice For example it can be used to calculate stETH / USD\n * @notice based on stETH / ETH and ETH / USD feeds.\n */\ncontract WBTCSynchronicityPriceAdapter is IHESynchronicityPriceAdapter {\n  /**\n   * @notice Price feed for (Base / Peg) pair\n   */\n  AggregatorV2V3Interface public immutable PEG_TO_BASE;\n\n  /**\n   * @notice Price feed for (Asset / Peg) pair\n   */\n  AggregatorV2V3Interface public immutable ASSET_TO_PEG;\n\n  /**\n   * @notice Number of decimals in the output of this price adapter\n   */\n  uint8 public immutable DECIMALS;\n\n  /**\n   * @notice This is a parameter to bring the resulting answer with the proper precision.\n   * @notice will be equal to 10 to the power of the sum decimals of feeds\n   */\n  int256 public immutable DENOMINATOR;\n\n  /**\n   * @notice Maximum number of resulting and feed decimals\n   */\n  uint8 public constant MAX_DECIMALS = 18;\n\n  /**\n   * @param pegToBaseAggregatorAddress the address of PEG / BASE feed\n   * @param assetToPegAggregatorAddress the address of the ASSET / PEG feed\n   * @param decimals precision of the answer\n   */\n  constructor(address pegToBaseAggregatorAddress, address assetToPegAggregatorAddress, uint8 decimals) {\n    PEG_TO_BASE = AggregatorV2V3Interface(pegToBaseAggregatorAddress);\n    ASSET_TO_PEG = AggregatorV2V3Interface(assetToPegAggregatorAddress);\n\n    if (decimals > MAX_DECIMALS) revert DecimalsAboveLimit();\n    if (PEG_TO_BASE.decimals() > MAX_DECIMALS) revert DecimalsAboveLimit();\n    if (ASSET_TO_PEG.decimals() > MAX_DECIMALS) revert DecimalsAboveLimit();\n\n    DECIMALS = decimals;\n\n    // equal to 10 to the power of the sum decimals of feeds\n    unchecked {\n      DENOMINATOR = int256(10 ** (PEG_TO_BASE.decimals() + ASSET_TO_PEG.decimals()));\n    }\n  }\n\n  /// @inheritdoc IHESynchronicityPriceAdapter\n  function latestAnswer() public view virtual override returns (int256) {\n    int256 assetToPegPrice = ASSET_TO_PEG.latestAnswer();\n    int256 pegToBasePrice = PEG_TO_BASE.latestAnswer();\n\n    if (assetToPegPrice <= 0 || pegToBasePrice <= 0) {\n      return 0;\n    }\n\n    return (assetToPegPrice * pegToBasePrice * int256(10 ** DECIMALS)) / (DENOMINATOR);\n  }\n\n  /// @inheritdoc IHESynchronicityPriceAdapter\n  function description() external view virtual override returns (string memory) {\n    return 'wBTC/USD';\n  }\n\n  /// @inheritdoc IHESynchronicityPriceAdapter\n  function decimals() external view virtual override returns (uint8) {\n    return DECIMALS;\n  }\n}\n"
    },
    "contracts/WstETHSynchronicityPriceAdapter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\nimport {AggregatorV2V3Interface} from './dependencies/chainlink/AggregatorV2V3Interface.sol';\nimport {IHESynchronicityPriceAdapter} from './interfaces/IHESynchronicityPriceAdapter.sol';\nimport {IStETH} from './interfaces/IStETH.sol';\n\n/**\n * @title WstETHSynchronicityPriceAdapter\n * @author Hope Ecosystem\n * @notice Price adapter to calculate price of (wstETH / USD) pair by using\n * @notice Chainlink data feed for (ETH / USD) and (wstETH / stETH) ratio.\n */\ncontract WstETHSynchronicityPriceAdapter is IHESynchronicityPriceAdapter {\n  /**\n   * @notice Price feed for (ETH / Base) pair\n   */\n  AggregatorV2V3Interface public immutable ETH_TO_BASE;\n\n  /**\n   * @notice stETH token contract to get ratio\n   */\n  IStETH public immutable STETH;\n\n  /**\n   * @notice Number of decimals for wstETH / stETH ratio\n   */\n  uint8 public constant RATIO_DECIMALS = 18;\n\n  /**\n   * @notice Number of decimals in the output of this price adapter\n   */\n  uint8 public immutable DECIMALS;\n\n  /**\n   * @param ethToBaseAggregatorAddress the address of ETH / BASE feed\n   * @param stEthAddress the address of the stETH contract\n   */\n  constructor(address ethToBaseAggregatorAddress, address stEthAddress) {\n    ETH_TO_BASE = AggregatorV2V3Interface(ethToBaseAggregatorAddress);\n    STETH = IStETH(stEthAddress);\n\n    DECIMALS = ETH_TO_BASE.decimals();\n  }\n\n  /// @inheritdoc IHESynchronicityPriceAdapter\n  function description() external view returns (string memory) {\n    return 'wstETH/ETH/USD';\n  }\n\n  /// @inheritdoc IHESynchronicityPriceAdapter\n  function decimals() external view returns (uint8) {\n    return DECIMALS;\n  }\n\n  /// @inheritdoc IHESynchronicityPriceAdapter\n  function latestAnswer() public view virtual override returns (int256) {\n    int256 ethToBasePrice = ETH_TO_BASE.latestAnswer();\n    int256 ratio = int256(STETH.getPooledEthByShares(10 ** RATIO_DECIMALS));\n\n    if (ethToBasePrice <= 0 || ratio <= 0) {\n      return 0;\n    }\n\n    return (ethToBasePrice * ratio) / int256(10 ** RATIO_DECIMALS);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}